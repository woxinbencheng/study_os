                    操作系统（Operating Systems）

                    第一节

操作系统将硬件抽象成了操作系统的调用：
1，CPU：抽象成了进程
2，硬盘：抽象成了文件
3，内存：抽象成了地址空间

操作系统的内外层次：
1，对内管理：Kernel(内核)
2，对外服务：Shell(外壳)


Kernel要管理的东西：

1，CPU调度             (CPU)
2，物理内存管理        (内存)
3，虚拟内存管理      
4，文件系统管理        (硬盘)
5，中断处理和设备驱动  (外设)


并发和并行：

1，并发：一段时间多个进程一起执行    (一个CPU,时间段处理多个进程)
2，并行：同意时间点多个进程一起执行 （多个CPU，同一时间处理多个进程）



操作系统很复杂:

1, windows xp 4500W 行
2，要求可靠，高效
3，操作系统是安全的基础
4，管理硬件是操作系统的主要工作

操作系统实例:

1，UNIX BSD
2，Linux
3，windows :前身是dos

操作系统分类:

1，实时操作系统:要求响应快
2，分时操作系统:每个程序都被分配同样的时间片，
依赖时钟产生计时中断多，任务多用户。
3，分布式操作系统：通过网络连接，一些任务交给远程的数据中心处理

操作系统结构：

1，紧耦合：所有操作系统功能都在内核中
2，微内核：松耦合，但是牺牲了性能
3，外核：分成面向硬件和面向应用两个部分，
由面向应用的内核访问面向硬件的内核
4，虚拟机:虚拟机层直接访问硬件，操作系统访问虚拟机层

                   第二节

操作系统的启动流程：

Disk：硬盘
BIOS：基本IO处理系统（base IO system ）
Bootloader:引导加载器（加载os）
CS：段寄存器
IP：指令寄存器

未加电时：
Bootloader在硬盘的第一扇区（512 B）
OS在硬盘上
BIOS在内存特定地址

加电后：

1，BIOS已经在内存的特定地址->CS:IP=0xf000:fff0

2,加电自检（POST）：寻找显卡等物理设备（执行物理设备驱动程序），
都在执行BIOS


3，BIOS检查硬件无误，加载Bootloader,将硬盘第一扇区的512B（Bootloader代码）
加载到Bootloader指定起始位置，并指令指针调到这个位置->CS:IP=0x0000:7c00

4，Bootloader的工作是加载操作系统，将操作系统从硬盘（起始位置和长度控制）
，加载到内存

5，指令指针调到操作系统所在内存位置，至此操作系统接管硬件设备。


内存图，如图：

－－－－－－－－－－－－共4GB
－                    －
－                    －
－                    －
－                    －
－ free space         －
－                    －
－                    －
－                    －
－－－－－－－－－－－－
－                    －
－os操作系统          －
－－－－－－－－－－－－
－                    －检查物理设备正常后，找到硬盘第一扇区，512B长度
－（第1步）           －将代码复制进内存起始位置为->0000:7c00
－BIOS ROM            －            （加载Bootloader）
－－－－－－－－－－－－f000:fff0
－                    －
－                    －
－  free space        －
－                    －
－                    －
－－－－－－－－－－－－
－                    －找到os的起始位置和os的代码长度，从硬盘将os
－（第2步)            －加载到内存
－512字节             －
－Bootloader          －
－－－－－－－－－－－－0000:7c00
－                    －
－BIOS DATA           －
－                    －
－－－－－－－－－－－－0000:0000

__________________________________________________________________________

操作系统主要面向的：

1,系统调用：应用程序请求的系统调用(system_call)，同步或异步
  之所以会异步，是因为有可能应用程序的需求资源没有准备好。
2,异常：应用程序所产生的错误操作，如除零操作，同步事件
3,中断：外部设备所产生的信号或（IO），异步事件

中断异常处理机制：

中断：
1，保存被打断的现场
2，中断表：表中有产生中断事件的编号，将中断事件标记，并编号
3，中断服务处理这个中断
4，清除中断标记
5，恢复原现场状态，继续执行原任务

异常：
1，保存异常现场
2，处理异常
   杀死产生异常的程序或重新执行异常指令
3，恢复现场

系统调用API：

1，windows：Win32 API
2，linux等：POSIX API
3，JAVA虚拟机：JAVA API（并非系统调用，封装了系统调用）


内核特点：

1，值得信任
2，权限大，可执行特权指令
3，方便应用程序：将外设等抽象成了系统调用


应用程序状态：

１，用户态：无法执行特权指令，有自己的应用程序堆栈
２，内核态：可以执行特权指令，有自己的内核堆栈


                        第三节

计算机体系结构和内存层次结构：

1，CPU：
   (1)运算器
   (2)控制器
   (3)寄存器
   (4)缓存--Cache
   (5)存储管理单元--MMU (逻辑内存和物理内存的映射关系)
2，内存：
3，外设：

-------------------------------------------
存储分层：

CPU层：
   寄存器
   缓存  
        L1 缓存
        L2 缓存
内存层：        
   主存     （就是内存条的逻辑内存）
硬盘层：
   虚拟内存 （硬盘的空间）
-------------------------------------------

操作系统在存储上的作用：

1，抽象：逻辑地址空间
2，保护：独立地址空间
3，共享：访问相同内存
4，虚拟化：更多地址空间(使用硬盘作虚拟内存)

--------------------------------------------

地址空间和地址空间生成：

1，物理地址空间
计算机内存和硬盘的空间
2，逻辑地址空间
程序员访问的一维空间

-----------------------------------------

存储碎片问题：

1，内碎片：给应用程序分配了一整块空间，这一部分空间中应用程序没办法全部用到
2，外碎片：逻辑内存，被切割出现的无法利用的空间

---------------------------------------------------

连续内存分配：

1，首次适配：遇到内存需求就挑第一个满足需求的内存进行分配
2，最优适配：找和内存需求大小，最相近的内存块，
进行分配（容易产生更小的碎片，将来不好使用）
3，最差适配：找和内存需求大小差距最大的内存空间进行分配（拆大块），
为了解决碎片过小问题（但遇到大块的需求就不好满足了）

----------------------------------------------------

减少碎片的算法：

1，紧制算法：让各各应用程序在逻辑内存中连续
2，换入换出（swap）：没有空闲内存的时候把不执行的程序放到硬盘上

------------------------------------------------------------------

                             第四节
非连续内存分配（解决连续内存分配问题）：

-----------------------------------------------------------------

分段：将逻辑内存中连续的内存地址，映射到物理内存不连续的空间
1，数据段
2，代码段
3，堆
4，栈
段的尺寸是不固定的
-------------------------------------------------------------------

分页：

1，祯(frames)：专指物理内存
2，页(pages)：专指逻辑内存
3，划分页祯的大小：2的幂次来划分
4,页和祯大小是相等的
##################################################################################
-----------------------------------------------------------------------------
祯：
物理地址是二元组（f,o）

f:祯号，一个祯号F位，共计2**F个祯
o：祯内偏移，一个o有S位，共计2**S字节（一祯）
注意：一个o是一个字节
物理地址：（2**S）* f +o
--------------------------------------------------------------------------
页：
页的计算方式和祯是完全相同的！
但，因为页是虚拟的，所以有多少页是可变的，而祯对应的物理空间是固定的，
所以，有多少祯是固定的。


页的尺寸是固定不变的

-------------------------------------------------------------------------

举例：
假设64位系统，一页1024字节，请算出页数P，祯数F，
答：
因为是64位系统，所以地址长度是64位
应为一页1024字节＝2**10，所以后10位表示页／祯内偏移，前54位表示页／祯号
#################################################################################

逻辑地址映射物理地址：页表（PageTable）

----------------------------------------------------------------------------------
页表的组成

1，高n位是Flag位,他的次高位为1表示此地址在物理内存中，为0表示不在物理内存中

2，低m位是Frame位，m记录了f(祯号)

页表的用法：
1，拿到1个逻辑内存地址A，A/（一页多少字节）＝P，此时P是页号。
2，2**x＝一页多少字节，得到的x，此时取低x位，计作O，O是页内偏移，同时也是祯内偏移。
3，通过P在页表索引，从0开始找到第P条，会得到一个k位的二进制，计作H。
4，取H的低x位，计作f，f就是物理地址的祯号
5，第4步的f和第2步的O，合成（f，O）元组，就是物理地址
6，取H的高k-x位，计作Flag，他就是（页表的组成）中的Flag。

---------------------------------------------------------------------------------

分页机制存在的问题和解决方法：

问题：

随着逻辑内存越来越大，页面太小会导致页表变得很大，这样在CPU寻址时影响效率。


解决：

1，通过catch(缓存)

TLB表(解决时间问题)：

直接在CPU中存放p：f值，p是逻辑地址的页数，f是逻辑地址的祯数
如此常用的地址就不用查页表（PageTable）了
查TLB时，如果有p值就直接找到物理地址，如果没有就将新的p：f对更新到TLB

2，通过Indirection(间接访问)

多级页表：

假设为二级页表，那么一个物理地址就被划分为P+O两部分，其中O为页内偏移
而P有被还分为两部分P＝P1+P2,其中P1代表1级页表的索引，P2代表2级页表的索引。
在1级页表中通过P1索引找到值，Flag位如果表示不存在，那么这个2级页表就不
会放在内存中，如果表示存在，那么Fram位表示的是二级页表中的起始位置，
然后通过P2索引，找到二级页表中的值，此时Fram位才表示物理内存的祯数

多级页表同理可知。

----------------------------------------------------------------

反向页表：

因为正向的页表是根据逻辑地址建立页表，所以机器位数越高，就要建立
越多的页表项。

反向页表，是根据物理地址空间建立页表，页表的大小只和机器实际物理内存
大小有关。

1，反向页表，以物理内存的祯号作为页表索引
2，这个索引，在页表中遍历，找到逻辑页所在的索引，就能对应物理祯号

----------------------------------------------------------------------
                            第五节

虚拟内存：

发展：
1，覆盖技术(overlay)：如果程序太大，把当前需要用的数据copy进内存，覆盖不用的数据

覆盖只能发生在互相之间没有调用关系的程序模块之间，他是发生在单独程序内部的。

2，交换技术(swapping)：如果程序太多，把暂时不运行的程序放在外存，内存只放当前要运行的程序

交换技术是对一个整个程序作为单位的，一换最小是一个程序。


3，自动的虚拟存储技术：如果想要在有限容量的内存中，以更小的页粒度为单位装入更多更大的程序。

要结合覆盖技术和交换技术的优点:
    1,互相之间没有联系的代码采用覆盖技术
    2,需要用的数据和不需要用的数据进行交换
要去除覆盖和交换技术的缺点:
    1,操作系统自己完成覆盖，而不是程序员
    2,交换是降低交换粒度，不要以整个程序作为单位进行交换

程序的局部性原理:指程序执行过程中的一段时间内，所执行的指令地址和指令操作数分别局限于一定区域:
    1，时间局部性：很短的时间内，多次访问，就是时间局部性。
    2，空间局部性：对临近的空间内，多次访问，就是空间局部性。
    例:
        for(i=0;i<1024;i++){
                for(j=0;j<1024,j++)
                {
                    访问数组A
                    }
                }
        如果A[i][j]此时的访问是连续的(因为逻辑内存是一维线性)，满足局部性
        如果A[j][i]此时的访问是不连续的，他先访问行，每次都要跨越行内的列空间

虚存技术的实现:
    1，在装入程序时，不必将所有都放入内存，只需要将当前需要执行的部分页／段
    装入内存，就可以让程序开始执行。
    2，缺页／缺段中断：在程序执行过程中，遇到需要的数据没在内存中，就要通知
    操作系统将需要的页／段装入内存，此时程序是没有执行的，这个中断就是缺页中断
    3，执行程序时，尽量满足时空局部性，用来减少缺页中断
    4，操作系统将内存中暂时不用的页／段，调出保存在外存，从而腾出更多内存空间

虚拟内存特征:
    1，大的用户空间：虚拟内存空间大于物理内存空间（物理内存+硬盘空间）
    2，部分交换：数据换入换出的单位是页／段，不是整个应用程序
    3，不连续性：物理内存分配不连续，虚拟地址空间也不连续

虚拟内存实现:
    1，设计页表数据段:
        驻留位：表示该页是否在内存中，会导出缺页中断
        保护位：对此页可以执行的权限，可读可写可执行
        修改位：此页是否被写过，如果被写过，需要从内存导会硬盘（主要影响置换）
        访问位：此页最近是否被访问过（置换操作时尽量换出被访问过的页）
    2，保存未被映射的页:
        1，能够识别二级存储器中的页
        2，交换空间（磁盘或文件）：特殊格式，用于存储未被映射的页面
    3，后备存储（backing store）:
        1，一个虚拟地址空间的页面可以被映射到一个文件中的某个位置
        2，代码段：映射到可执行二进制文件
        3，动态链接库程序段：映射到动态调用的库文件
        4，其他段：可能被映射到交换文件（swap file）

虚拟内存性能:
    EAT:进行一次内存访问的平均时间
    EAT＝访问内存的平均时间+访问硬盘的平均时间 （其实平均的意义是内存和硬盘访问的比例）
    访问内存的平均时间＝单次访问内存的时间*内存访问概率
    访问硬盘的平均时间＝单此访问硬盘的时间*硬盘访问概率
    例:
        内存访问时间：10ns
        磁盘访问时间：5ms
        P（page fault）：缺页的概率
        Q（dirty page）：对数据进行写操作的概率
        EAT＝10（1-P）+5000000（1+Q）*P
        其中:
            10(1-P)项：（1－P）表示访问的逻辑内存在物理内存上有映射的概率

            5000000*（1+Q）*P:
                如果发生写操作，那么首先要将写的数据写入硬盘
                                    之后，将整个数据读出硬盘进内存
            以上两步表诉为5000000*（1＋Q）
            最后5000000（1+Q）*P，就是访问硬盘时间的期望值
        当P足够小，那么虚拟内存就很有效率


-----------------------------------------------------------------------------------

                               第六节
页面置换算法:
    1,功能:当缺页中断发生，需要调入新的页而内存已满时，选择内存中的那个页被置换
    2,目标:尽可能减少发生缺页中断的次数，把未来短时间内不使用的页面换出，通常依据局部
    原理，根据过去的统计数据进行预测
    3,页面锁定:有些页面需要常驻内存，或短时间内不要被换出内存，就要添加页面锁定
    ，实现方法是：页表中添加标志位

局部页面置换算法:
    研究单个程序，在给定物理页祯数(内存)的情况下，如何减少缺页中断的产生次数,
    也就是提高单位内存的利用率。

1,最优页面置换算法:
    
    目标:当一个缺页中断发生就计算在物理内存中的每一个页将来需要多久才被访问
    ，把时间最长的那个置换出去

    然而：这是一个理想情况，实际操作系统无法知道每个页面需要等待多少时间才再次被访问

    但是：此算法可以作为评价其他算法的标准

2,先进先出算法(FIFO):

    思路:把驻留时间最长的页替换出内存。

    然而：性能很差，被调出的页面可能经常被访问到

3,最近最久位使用算法(LRU):

    思路:最长时间没被使用的页被换出去

4,时钟页面置换算法(CLOCK):

    访问位:计算机访问一个页后会自动的把这一位置1。

    思路:将当前所有在物理内存中的页组成一个环形，当发生缺页中断时，访问指针
    就开始转动，如果遇到访问位为0，就认为这个页很久没被用过，就将这个页替换出去
    如果遇到访问位是1，就将访问位清0。直到遇到访问位是0的页。

    贴近3算法的效果

5,二次算法:

    脏位(dirty bit):这个位描述这个页是否被写过，区分读.写位,如果发生写操作，硬件会
    将此位置1。

    思路:如果一个页被进行了写操作，就认为他会被经常使用，要给这个页更多机会
    驻留在内存中，此时，只有访问位和脏位同时为0才替换这个页，访问指针一直转
    转一圈就将访问位和脏位中的一个置0。

6,最不常用算法(LFU):
    对比3算法

    基本思路:选择访问次数最少的那个页面，并换出

    实现方法:每个页都设置一个计数器，每当一个页面被访问时，该页面访问计数器加
    1，发生缺页中断时，淘汰计数值最小的那个页面。


Belady现象:采用先进先出(FIFO)算法时，有时会出现分配的物理页祯数增加，
缺页率反而提高的异常现象。

上面的算法针对的是局部，单进程

----------------------------------------------------------------

全局页面算法:
    研究多个程序运行的情况下，如何为每个程序分配最合理的物理页祯数(内存)，
    也就是如何合理的动态分配内存。


工作集模型:

   1， 工作集:一个进程当前正在使用的逻辑页面的集合。

   可以用一个二元组，表示工作集 W(T,dt):
       T,表示当前时刻
       dt,表示T时刻之前的一段时间，这个时间是要重点研究的
       W(T,dt):表示在T时刻时，从[T-dt,T],这个时间区间中，所有被访问的逻辑页
       |W(T,dt)|:表示逻辑页数量

   2,常驻集:当前时刻,进程实际在驻留在物理内存的逻辑页面的集合。
       工作集和常驻集的区别:
           1,决定工作集的参数是dt和逻辑页访问次序，其中逻辑页次序不可预知，是客观的。
           2,常驻集，是我们希望通过调整算法，使得工作集，尽量都在物理内存当中，减少缺页中断。


   3,两个常用的置换算法:

       1,工作集页置换算法:

           dt等于一个常数,W(T,dt)就会得到他的工作集:也就是物理内存中只保留，最近dt个被访问的逻辑页,
           被访问时间超出dt的逻辑页会被主动换出。

       2,缺页率页面置换算法:

           实际上就是dt变成可变的。

           1,记录两次缺页中断发生的时间t1,t2，并设置一个阈值t。
           2,如果t2-t1>t,说明物理内存分配的大了,就设置W(T,t2-t1),这样不在t2-t1时间段内被访问的逻辑页就被换出,同时将中断页加入工作集。
           3,如果t2-t1<=t,那么就将中断页(Wn)加入工作集W(T)+=Wn

抖动问题:

    抖动: 如果分配给一个进程的物理页祯太少，就会造成常驻集不能包含工作集，进程
    会有很多缺页中断，这种状态叫做抖动。

    解决办法:选择合理的进程数和进程分配祯数，使进程并发量和内存效率达到一个最好
    的平衡点,平均缺页时间＝缺页服务时间。



-----------------------------------------------------------------------------
进程管理:
