                    操作系统（Operating Systems）

                    第一节

操作系统将硬件抽象成了操作系统的调用：
1，CPU：抽象成了进程
2，硬盘：抽象成了文件
3，内存：抽象成了地址空间

操作系统的内外层次：
1，对内管理：Kernel(内核)
2，对外服务：Shell(外壳)


Kernel要管理的东西：

1，CPU调度             (CPU)
2，物理内存管理        (内存)
3，虚拟内存管理      
4，文件系统管理        (硬盘)
5，中断处理和设备驱动  (外设)


并发和并行：

1，并发：一段时间多个进程一起执行    (一个CPU,时间段处理多个进程)
2，并行：同意时间点多个进程一起执行 （多个CPU，同一时间处理多个进程）



操作系统很复杂:

1, windows xp 4500W 行
2，要求可靠，高效
3，操作系统是安全的基础
4，管理硬件是操作系统的主要工作

操作系统实例:

1，UNIX BSD
2，Linux
3，windows :前身是dos

操作系统分类:

1，实时操作系统:要求响应快
2，分时操作系统:每个程序都被分配同样的时间片，
依赖时钟产生计时中断多，任务多用户。
3，分布式操作系统：通过网络连接，一些任务交给远程的数据中心处理

操作系统结构：

1，紧耦合：所有操作系统功能都在内核中
2，微内核：松耦合，但是牺牲了性能
3，外核：分成面向硬件和面向应用两个部分，
由面向应用的内核访问面向硬件的内核
4，虚拟机:虚拟机层直接访问硬件，操作系统访问虚拟机层

                   第二节

操作系统的启动流程：

Disk：硬盘
BIOS：基本IO处理系统（base IO system ）
Bootloader:引导加载器（加载os）
CS：段寄存器
IP：指令寄存器

未加电时：
Bootloader在硬盘的第一扇区（512 B）
OS在硬盘上
BIOS在内存特定地址

加电后：

1，BIOS已经在内存的特定地址->CS:IP=0xf000:fff0

2,加电自检（POST）：寻找显卡等物理设备（执行物理设备驱动程序），
都在执行BIOS


3，BIOS检查硬件无误，加载Bootloader,将硬盘第一扇区的512B（Bootloader代码）
加载到Bootloader指定起始位置，并指令指针调到这个位置->CS:IP=0x0000:7c00

4，Bootloader的工作是加载操作系统，将操作系统从硬盘（起始位置和长度控制）
，加载到内存

5，指令指针调到操作系统所在内存位置，至此操作系统接管硬件设备。


内存图，如图：

－－－－－－－－－－－－共4GB
－                    －
－                    －
－                    －
－                    －
－ free space         －
－                    －
－                    －
－                    －
－－－－－－－－－－－－
－                    －
－os操作系统          －
－－－－－－－－－－－－
－                    －检查物理设备正常后，找到硬盘第一扇区，512B长度
－（第1步）           －将代码复制进内存起始位置为->0000:7c00
－BIOS ROM            －            （加载Bootloader）
－－－－－－－－－－－－f000:fff0
－                    －
－                    －
－  free space        －
－                    －
－                    －
－－－－－－－－－－－－
－                    －找到os的起始位置和os的代码长度，从硬盘将os
－（第2步)            －加载到内存
－512字节             －
－Bootloader          －
－－－－－－－－－－－－0000:7c00
－                    －
－BIOS DATA           －
－                    －
－－－－－－－－－－－－0000:0000

__________________________________________________________________________

操作系统主要面向的：

1,系统调用：应用程序请求的系统调用(system_call)，同步或异步
  之所以会异步，是因为有可能应用程序的需求资源没有准备好。
2,异常：应用程序所产生的错误操作，如除零操作，同步事件
3,中断：外部设备所产生的信号或（IO），异步事件

中断异常处理机制：

中断：
1，保存被打断的现场
2，中断表：表中有产生中断事件的编号，将中断事件标记，并编号
3，中断服务处理这个中断
4，清除中断标记
5，恢复原现场状态，继续执行原任务

异常：
1，保存异常现场
2，处理异常
   杀死产生异常的程序或重新执行异常指令
3，恢复现场

系统调用API：

1，windows：Win32 API
2，linux等：POSIX API
3，JAVA虚拟机：JAVA API（并非系统调用，封装了系统调用）


内核特点：

1，值得信任
2，权限大，可执行特权指令
3，方便应用程序：将外设等抽象成了系统调用


应用程序状态：

１，用户态：无法执行特权指令，有自己的应用程序堆栈
２，内核态：可以执行特权指令，有自己的内核堆栈


                        第三节

计算机体系结构和内存层次结构：

1，CPU：
   (1)运算器
   (2)控制器
   (3)寄存器
   (4)缓存--Cache
   (5)存储管理单元--MMU (逻辑内存和物理内存的映射关系)
2，内存：
3，外设：

-------------------------------------------
存储分层：

CPU层：
   寄存器
   缓存  
        L1 缓存
        L2 缓存
内存层：        
   主存     （就是内存条的逻辑内存）
硬盘层：
   虚拟内存 （硬盘的空间）
-------------------------------------------

操作系统在存储上的作用：

1，抽象：逻辑地址空间
2，保护：独立地址空间
3，共享：访问相同内存
4，虚拟化：更多地址空间(使用硬盘作虚拟内存)

--------------------------------------------

地址空间和地址空间生成：

1，物理地址空间
计算机内存和硬盘的空间
2，逻辑地址空间
程序员访问的一维空间

-----------------------------------------

存储碎片问题：

1，内碎片：给应用程序分配了一整块空间，这一部分空间中应用程序没办法全部用到
2，外碎片：逻辑内存，被切割出现的无法利用的空间

---------------------------------------------------

连续内存分配：

1，首次适配：遇到内存需求就挑第一个满足需求的内存进行分配
2，最优适配：找和内存需求大小，最相近的内存块，
进行分配（容易产生更小的碎片，将来不好使用）
3，最差适配：找和内存需求大小差距最大的内存空间进行分配（拆大块），
为了解决碎片过小问题（但遇到大块的需求就不好满足了）

----------------------------------------------------

减少碎片的算法：

1，紧制算法：让各各应用程序在逻辑内存中连续
2，换入换出（swap）：没有空闲内存的时候把不执行的程序放到硬盘上

------------------------------------------------------------------

                             第四节
非连续内存分配（解决连续内存分配问题）：

-----------------------------------------------------------------

分段：将逻辑内存中连续的内存地址，映射到物理内存不连续的空间
1，数据段
2，代码段
3，堆
4，栈
段的尺寸是不固定的
-------------------------------------------------------------------

分页：

1，祯(frames)：专指物理内存
2，页(pages)：专指逻辑内存
3，划分页祯的大小：2的幂次来划分
4,页和祯大小是相等的
##################################################################################
-----------------------------------------------------------------------------
祯：
物理地址是二元组（f,o）

f:祯号，一个祯号F位，共计2**F个祯
o：祯内偏移，一个o有S位，共计2**S字节（一祯）
注意：一个o是一个字节
物理地址：（2**S）* f +o
--------------------------------------------------------------------------
页：
页的计算方式和祯是完全相同的！
但，因为页是虚拟的，所以有多少页是可变的，而祯对应的物理空间是固定的，
所以，有多少祯是固定的。


页的尺寸是固定不变的

-------------------------------------------------------------------------

举例：
假设64位系统，一页1024字节，请算出页数P，祯数F，
答：
因为是64位系统，所以地址长度是64位
应为一页1024字节＝2**10，所以后10位表示页／祯内偏移，前54位表示页／祯号
#################################################################################

逻辑地址映射物理地址：页表（PageTable）

----------------------------------------------------------------------------------
页表的组成

1，高n位是Flag位,他的次高位为1表示此地址在物理内存中，为0表示不在物理内存中

2，低m位是Frame位，m记录了f(祯号)

页表的用法：
1，拿到1个逻辑内存地址A，A/（一页多少字节）＝P，此时P是页号。
2，2**x＝一页多少字节，得到的x，此时取低x位，计作O，O是页内偏移，同时也是祯内偏移。
3，通过P在页表索引，从0开始找到第P条，会得到一个k位的二进制，计作H。
4，取H的低x位，计作f，f就是物理地址的祯号
5，第4步的f和第2步的O，合成（f，O）元组，就是物理地址
6，取H的高k-x位，计作Flag，他就是（页表的组成）中的Flag。

---------------------------------------------------------------------------------

分页机制存在的问题和解决方法：

问题：

随着逻辑内存越来越大，页面太小会导致页表变得很大，这样在CPU寻址时影响效率。


解决：

1，通过catch(缓存)

TLB表(解决时间问题)：

直接在CPU中存放p：f值，p是逻辑地址的页数，f是逻辑地址的祯数
如此常用的地址就不用查页表（PageTable）了
查TLB时，如果有p值就直接找到物理地址，如果没有就将新的p：f对更新到TLB

2，通过Indirection(间接访问)

多级页表：

假设为二级页表，那么一个物理地址就被划分为P+O两部分，其中O为页内偏移
而P有被还分为两部分P＝P1+P2,其中P1代表1级页表的索引，P2代表2级页表的索引。
在1级页表中通过P1索引找到值，Flag位如果表示不存在，那么这个2级页表就不
会放在内存中，如果表示存在，那么Fram位表示的是二级页表中的起始位置，
然后通过P2索引，找到二级页表中的值，此时Fram位才表示物理内存的祯数

多级页表同理可知。


