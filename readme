                    操作系统（Operating Systems）

                    第一节

操作系统将硬件抽象成了操作系统的调用：
1，CPU：抽象成了进程
2，硬盘：抽象成了文件
3，内存：抽象成了地址空间

操作系统的内外层次：
1，对内管理：Kernel(内核)
2，对外服务：Shell(外壳)


Kernel要管理的东西：

1，CPU调度             (CPU)
2，物理内存管理        (内存)
3，虚拟内存管理      
4，文件系统管理        (硬盘)
5，中断处理和设备驱动  (外设)


并发和并行：

1，并发：一段时间多个进程一起执行    (一个CPU,时间段处理多个进程)
2，并行：同意时间点多个进程一起执行 （多个CPU，同一时间处理多个进程）



操作系统很复杂:

1, windows xp 4500W 行
2，要求可靠，高效
3，操作系统是安全的基础
4，管理硬件是操作系统的主要工作

操作系统实例:

1，UNIX BSD
2，Linux
3，windows :前身是dos

操作系统分类:

1，实时操作系统:要求响应快
2，分时操作系统:每个程序都被分配同样的时间片，
依赖时钟产生计时中断多，任务多用户。
3，分布式操作系统：通过网络连接，一些任务交给远程的数据中心处理

操作系统结构：

1，紧耦合：所有操作系统功能都在内核中
2，微内核：松耦合，但是牺牲了性能
3，外核：分成面向硬件和面向应用两个部分，
由面向应用的内核访问面向硬件的内核
4，虚拟机:虚拟机层直接访问硬件，操作系统访问虚拟机层

                   第二节

操作系统的启动流程：

Disk：硬盘
BIOS：基本IO处理系统（base IO system ）
Bootloader:引导加载器（加载os）
CS：段寄存器
IP：指令寄存器

未加电时：
Bootloader在硬盘的第一扇区（512 B）
OS在硬盘上
BIOS在内存特定地址

加电后：

1，BIOS已经在内存的特定地址->CS:IP=0xf000:fff0

2,加电自检（POST）：寻找显卡等物理设备（执行物理设备驱动程序），
都在执行BIOS


3，BIOS检查硬件无误，加载Bootloader,将硬盘第一扇区的512B（Bootloader代码）
加载到Bootloader指定起始位置，并指令指针调到这个位置->CS:IP=0x0000:7c00

4，Bootloader的工作是加载操作系统，将操作系统从硬盘（起始位置和长度控制）
，加载到内存

5，指令指针调到操作系统所在内存位置，至此操作系统接管硬件设备。


内存图，如图：

－－－－－－－－－－－－共4GB
－                    －
－                    －
－                    －
－                    －
－ free space         －
－                    －
－                    －
－                    －
－－－－－－－－－－－－
－                    －
－os操作系统          －
－－－－－－－－－－－－
－                    －检查物理设备正常后，找到硬盘第一扇区，512B长度
－（第1步）           －将代码复制进内存起始位置为->0000:7c00
－BIOS ROM            －            （加载Bootloader）
－－－－－－－－－－－－f000:fff0
－                    －
－                    －
－  free space        －
－                    －
－                    －
－－－－－－－－－－－－
－                    －找到os的起始位置和os的代码长度，从硬盘将os
－（第2步)            －加载到内存
－512字节             －
－Bootloader          －
－－－－－－－－－－－－0000:7c00
－                    －
－BIOS DATA           －
－                    －
－－－－－－－－－－－－0000:0000

__________________________________________________________________________

操作系统主要面向的：

1,系统调用：应用程序请求的系统调用(system_call)，同步或异步
  之所以会异步，是因为有可能应用程序的需求资源没有准备好。
2,异常：应用程序所产生的错误操作，如除零操作，同步事件
3,中断：外部设备所产生的信号或（IO），异步事件

中断异常处理机制：

中断：
1，保存被打断的现场
2，中断表：表中有产生中断事件的编号，将中断事件标记，并编号
3，中断服务处理这个中断
4，清除中断标记
5，恢复原现场状态，继续执行原任务

异常：
1，保存异常现场
2，处理异常
   杀死产生异常的程序或重新执行异常指令
3，恢复现场

系统调用API：

1，windows：Win32 API
2，linux等：POSIX API
3，JAVA虚拟机：JAVA API（并非系统调用，封装了系统调用）


内核特点：

1，值得信任
2，权限大，可执行特权指令
3，方便应用程序：将外设等抽象成了系统调用


应用程序状态：

１，用户态：无法执行特权指令，有自己的应用程序堆栈
２，内核态：可以执行特权指令，有自己的内核堆栈


                        第三节

计算机体系结构和内存层次结构：

1，CPU：
   (1)运算器
   (2)控制器
   (3)寄存器
   (4)缓存--Cache
   (5)存储管理单元--MMU (逻辑内存和物理内存的映射关系)
2，内存：
3，外设：

-------------------------------------------
存储分层：

CPU层：
   寄存器
   缓存  
        L1 缓存
        L2 缓存
内存层：        
   主存     （就是内存条的逻辑内存）
硬盘层：
   虚拟内存 （硬盘的空间）
-------------------------------------------

操作系统在存储上的作用：

1，抽象：逻辑地址空间
2，保护：独立地址空间
3，共享：访问相同内存
4，虚拟化：更多地址空间(使用硬盘作虚拟内存)

--------------------------------------------

地址空间和地址空间生成：

1，物理地址空间
计算机内存和硬盘的空间
2，逻辑地址空间
程序员访问的一维空间

-----------------------------------------

存储碎片问题：

1，内碎片：给应用程序分配了一整块空间，这一部分空间中应用程序没办法全部用到
2，外碎片：逻辑内存，被切割出现的无法利用的空间

---------------------------------------------------

连续内存分配：

1，首次适配：遇到内存需求就挑第一个满足需求的内存进行分配
2，最优适配：找和内存需求大小，最相近的内存块，
进行分配（容易产生更小的碎片，将来不好使用）
3，最差适配：找和内存需求大小差距最大的内存空间进行分配（拆大块），
为了解决碎片过小问题（但遇到大块的需求就不好满足了）

----------------------------------------------------

减少碎片的算法：

1，紧制算法：让各各应用程序在逻辑内存中连续
2，换入换出（swap）：没有空闲内存的时候把不执行的程序放到硬盘上

------------------------------------------------------------------

                             第四节
非连续内存分配（解决连续内存分配问题）：

-----------------------------------------------------------------

分段：将逻辑内存中连续的内存地址，映射到物理内存不连续的空间
1，数据段
2，代码段
3，堆
4，栈
段的尺寸是不固定的
-------------------------------------------------------------------

分页：

1，祯(frames)：专指物理内存
2，页(pages)：专指逻辑内存
3，划分页祯的大小：2的幂次来划分
4,页和祯大小是相等的
##################################################################################
-----------------------------------------------------------------------------
祯：
物理地址是二元组（f,o）

f:祯号，一个祯号F位，共计2**F个祯
o：祯内偏移，一个o有S位，共计2**S字节（一祯）
注意：一个o是一个字节
物理地址：（2**S）* f +o
--------------------------------------------------------------------------
页：
页的计算方式和祯是完全相同的！
但，因为页是虚拟的，所以有多少页是可变的，而祯对应的物理空间是固定的，
所以，有多少祯是固定的。


页的尺寸是固定不变的

-------------------------------------------------------------------------

举例：
假设64位系统，一页1024字节，请算出页数P，祯数F，
答：
因为是64位系统，所以地址长度是64位
应为一页1024字节＝2**10，所以后10位表示页／祯内偏移，前54位表示页／祯号
#################################################################################

逻辑地址映射物理地址：页表（PageTable）

----------------------------------------------------------------------------------
页表的组成

1，高n位是Flag位,他的次高位为1表示此地址在物理内存中，为0表示不在物理内存中

2，低m位是Frame位，m记录了f(祯号)

页表的用法：
1，拿到1个逻辑内存地址A，A/（一页多少字节）＝P，此时P是页号。
2，2**x＝一页多少字节，得到的x，此时取低x位，计作O，O是页内偏移，同时也是祯内偏移。
3，通过P在页表索引，从0开始找到第P条，会得到一个k位的二进制，计作H。
4，取H的低x位，计作f，f就是物理地址的祯号
5，第4步的f和第2步的O，合成（f，O）元组，就是物理地址
6，取H的高k-x位，计作Flag，他就是（页表的组成）中的Flag。

---------------------------------------------------------------------------------

分页机制存在的问题和解决方法：

问题：

随着逻辑内存越来越大，页面太小会导致页表变得很大，这样在CPU寻址时影响效率。


解决：

1，通过catch(缓存)

TLB表(解决时间问题)：

直接在CPU中存放p：f值，p是逻辑地址的页数，f是逻辑地址的祯数
如此常用的地址就不用查页表（PageTable）了
查TLB时，如果有p值就直接找到物理地址，如果没有就将新的p：f对更新到TLB

2，通过Indirection(间接访问)

多级页表：

假设为二级页表，那么一个物理地址就被划分为P+O两部分，其中O为页内偏移
而P有被还分为两部分P＝P1+P2,其中P1代表1级页表的索引，P2代表2级页表的索引。
在1级页表中通过P1索引找到值，Flag位如果表示不存在，那么这个2级页表就不
会放在内存中，如果表示存在，那么Fram位表示的是二级页表中的起始位置，
然后通过P2索引，找到二级页表中的值，此时Fram位才表示物理内存的祯数

多级页表同理可知。

----------------------------------------------------------------

反向页表：

因为正向的页表是根据逻辑地址建立页表，所以机器位数越高，就要建立
越多的页表项。

反向页表，是根据物理地址空间建立页表，页表的大小只和机器实际物理内存
大小有关。

1，反向页表，以物理内存的祯号作为页表索引
2，这个索引，在页表中遍历，找到逻辑页所在的索引，就能对应物理祯号

----------------------------------------------------------------------
                            第五节

虚拟内存：

发展：
1，覆盖技术(overlay)：如果程序太大，把当前需要用的数据copy进内存，覆盖不用的数据

覆盖只能发生在互相之间没有调用关系的程序模块之间，他是发生在单独程序内部的。

2，交换技术(swapping)：如果程序太多，把暂时不运行的程序放在外存，内存只放当前要运行的程序

交换技术是对一个整个程序作为单位的，一换最小是一个程序。


3，自动的虚拟存储技术：如果想要在有限容量的内存中，以更小的页粒度为单位装入更多更大的程序。

要结合覆盖技术和交换技术的优点:
    1,互相之间没有联系的代码采用覆盖技术
    2,需要用的数据和不需要用的数据进行交换
要去除覆盖和交换技术的缺点:
    1,操作系统自己完成覆盖，而不是程序员
    2,交换是降低交换粒度，不要以整个程序作为单位进行交换

程序的局部性原理:指程序执行过程中的一段时间内，所执行的指令地址和指令操作数分别局限于一定区域:
    1，时间局部性：很短的时间内，多次访问，就是时间局部性。
    2，空间局部性：对临近的空间内，多次访问，就是空间局部性。
    例:
        for(i=0;i<1024;i++){
                for(j=0;j<1024,j++)
                {
                    访问数组A
                    }
                }
        如果A[i][j]此时的访问是连续的(因为逻辑内存是一维线性)，满足局部性
        如果A[j][i]此时的访问是不连续的，他先访问行，每次都要跨越行内的列空间

虚存技术的实现:
    1，在装入程序时，不必将所有都放入内存，只需要将当前需要执行的部分页／段
    装入内存，就可以让程序开始执行。
    2，缺页／缺段中断：在程序执行过程中，遇到需要的数据没在内存中，就要通知
    操作系统将需要的页／段装入内存，此时程序是没有执行的，这个中断就是缺页中断
    3，执行程序时，尽量满足时空局部性，用来减少缺页中断
    4，操作系统将内存中暂时不用的页／段，调出保存在外存，从而腾出更多内存空间

虚拟内存特征:
    1，大的用户空间：虚拟内存空间大于物理内存空间（物理内存+硬盘空间）
    2，部分交换：数据换入换出的单位是页／段，不是整个应用程序
    3，不连续性：物理内存分配不连续，虚拟地址空间也不连续

虚拟内存实现:
    1，设计页表数据段:
        驻留位：表示该页是否在内存中，会导出缺页中断
        保护位：对此页可以执行的权限，可读可写可执行
        修改位：此页是否被写过，如果被写过，需要从内存导会硬盘（主要影响置换）
        访问位：此页最近是否被访问过（置换操作时尽量换出被访问过的页）
    2，保存未被映射的页:
        1，能够识别二级存储器中的页
        2，交换空间（磁盘或文件）：特殊格式，用于存储未被映射的页面
    3，后备存储（backing store）:
        1，一个虚拟地址空间的页面可以被映射到一个文件中的某个位置
        2，代码段：映射到可执行二进制文件
        3，动态链接库程序段：映射到动态调用的库文件
        4，其他段：可能被映射到交换文件（swap file）

虚拟内存性能:
    EAT:进行一次内存访问的平均时间
    EAT＝访问内存的平均时间+访问硬盘的平均时间 （其实平均的意义是内存和硬盘访问的比例）
    访问内存的平均时间＝单次访问内存的时间*内存访问概率
    访问硬盘的平均时间＝单此访问硬盘的时间*硬盘访问概率
    例:
        内存访问时间：10ns
        磁盘访问时间：5ms
        P（page fault）：缺页的概率
        Q（dirty page）：对数据进行写操作的概率
        EAT＝10（1-P）+5000000（1+Q）*P
        其中:
            10(1-P)项：（1－P）表示访问的逻辑内存在物理内存上有映射的概率

            5000000*（1+Q）*P:
                如果发生写操作，那么首先要将写的数据写入硬盘
                                    之后，将整个数据读出硬盘进内存
            以上两步表诉为5000000*（1＋Q）
            最后5000000（1+Q）*P，就是访问硬盘时间的期望值
        当P足够小，那么虚拟内存就很有效率


-----------------------------------------------------------------------------------

                               第六节
页面置换算法:
    1,功能:当缺页中断发生，需要调入新的页而内存已满时，选择内存中的那个页被置换
    2,目标:尽可能减少发生缺页中断的次数，把未来短时间内不使用的页面换出，通常依据局部
    原理，根据过去的统计数据进行预测
    3,页面锁定:有些页面需要常驻内存，或短时间内不要被换出内存，就要添加页面锁定
    ，实现方法是：页表中添加标志位

局部页面置换算法:
    研究单个程序，在给定物理页祯数(内存)的情况下，如何减少缺页中断的产生次数,
    也就是提高单位内存的利用率。

1,最优页面置换算法:
    
    目标:当一个缺页中断发生就计算在物理内存中的每一个页将来需要多久才被访问
    ，把时间最长的那个置换出去

    然而：这是一个理想情况，实际操作系统无法知道每个页面需要等待多少时间才再次被访问

    但是：此算法可以作为评价其他算法的标准

2,先进先出算法(FIFO):

    思路:把驻留时间最长的页替换出内存。

    然而：性能很差，被调出的页面可能经常被访问到

3,最近最久位使用算法(LRU):

    思路:最长时间没被使用的页被换出去

4,时钟页面置换算法(CLOCK):

    访问位:计算机访问一个页后会自动的把这一位置1。

    思路:将当前所有在物理内存中的页组成一个环形，当发生缺页中断时，访问指针
    就开始转动，如果遇到访问位为0，就认为这个页很久没被用过，就将这个页替换出去
    如果遇到访问位是1，就将访问位清0。直到遇到访问位是0的页。

    贴近3算法的效果

5,二次算法:

    脏位(dirty bit):这个位描述这个页是否被写过，区分读.写位,如果发生写操作，硬件会
    将此位置1。

    思路:如果一个页被进行了写操作，就认为他会被经常使用，要给这个页更多机会
    驻留在内存中，此时，只有访问位和脏位同时为0才替换这个页，访问指针一直转
    转一圈就将访问位和脏位中的一个置0。

6,最不常用算法(LFU):
    对比3算法

    基本思路:选择访问次数最少的那个页面，并换出

    实现方法:每个页都设置一个计数器，每当一个页面被访问时，该页面访问计数器加
    1，发生缺页中断时，淘汰计数值最小的那个页面。


Belady现象:采用先进先出(FIFO)算法时，有时会出现分配的物理页祯数增加，
缺页率反而提高的异常现象。

上面的算法针对的是局部，单进程

----------------------------------------------------------------

全局页面算法:
    研究多个程序运行的情况下，如何为每个程序分配最合理的物理页祯数(内存)，
    也就是如何合理的动态分配内存。


工作集模型:

   1， 工作集:一个进程当前正在使用的逻辑页面的集合。

   可以用一个二元组，表示工作集 W(T,dt):
       T,表示当前时刻
       dt,表示T时刻之前的一段时间，这个时间是要重点研究的
       W(T,dt):表示在T时刻时，从[T-dt,T],这个时间区间中，所有被访问的逻辑页
       |W(T,dt)|:表示逻辑页数量

   2,常驻集:当前时刻,进程实际在驻留在物理内存的逻辑页面的集合。
       工作集和常驻集的区别:
           1,决定工作集的参数是dt和逻辑页访问次序，其中逻辑页次序不可预知，是客观的。
           2,常驻集，是我们希望通过调整算法，使得工作集，尽量都在物理内存当中，减少缺页中断。


   3,两个常用的置换算法:

       1,工作集页置换算法:

           dt等于一个常数,W(T,dt)就会得到他的工作集:也就是物理内存中只保留，最近dt个被访问的逻辑页,
           被访问时间超出dt的逻辑页会被主动换出。

       2,缺页率页面置换算法:

           实际上就是dt变成可变的。

           1,记录两次缺页中断发生的时间t1,t2，并设置一个阈值t。
           2,如果t2-t1>t,说明物理内存分配的大了,就设置W(T,t2-t1),这样不在t2-t1时间段内被访问的逻辑页就被换出,同时将中断页加入工作集。
           3,如果t2-t1<=t,那么就将中断页(Wn)加入工作集W(T)+=Wn

抖动问题:

    抖动: 如果分配给一个进程的物理页祯太少，就会造成常驻集不能包含工作集，进程
    会有很多缺页中断，这种状态叫做抖动。

    解决办法:选择合理的进程数和进程分配祯数，使进程并发量和内存效率达到一个最好
    的平衡点,平均缺页时间＝缺页服务时间。



-----------------------------------------------------------------------------
                               第七节
进程:

进程的定义:一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程

进程的构成:
   1,进程控制块(PCB)
   2,程序
   3,数据

进程控制块(PCB):

	1,进程标识信息(进程的唯一标志):

	   1,本进程标识
	   2,本进程的父进程标识
	   3,用户标识

	2,处理器状态信息保存区(保存进程的运行现场信息):
	   
	   1,用户可见寄存器
	   2,控制和状态寄存器
	   3,栈指针

	3,进程控制信息:
	   
	   1,调度和状态信息
	   2,进程间通信信息
	   3,存储管理信息
	   4,进程所用资源
	   5,有关数据结构连接信息

进程的生命周期:

  1,创建:

    引起进程创建的3个主要事件:
	  1,系统初始化时
	  2,用户请求创建一个新进程
	  3,正在运行的进程执行了创建进程的系统调用
	     1,用户登陆

  2,运行:
    
    内核选择一个就绪的进程,让它占用处理器并执行

  3,等待:
    
    就是进程阻塞

	1,请求并等待系统服务,无法马上完成
	2,启动某种操作,无法马上完成
	3,需求的数据没有到达

	因为上述原因,进程只能自己阻塞自己,因为只有进程自身
	才知道何时需要等待某种事件

  4,唤醒:

    唤醒进程的原因:
	  
	  1,该进程的PCB插入到就绪队列
	  2,被阻塞进程需要的资源可被满足
	  3,被阻塞进程等待的事件到达

	进程只能被别的进程或操作系统唤醒(因为没有占用CPU执行)

  5,结束

    结束的四种情形:

	  1,正常退出(自愿的)
	  2,错误退出(自愿的)
	  3,致命错误(强制性的)
	  4,被其他进程所杀(强制性的)


进程状态变化模型:

  进程的三种基本状态:
     
     进程在生命结束前处于且仅处于三种基本状态之一,
	 不同系统设置的进程状态数目不同。

	 1,运行态(Running):得到处理机,正在处理机上运行时

	 2,就绪态(Ready):一个进程获得了除处理机之外的一切所需
					 资源,一旦得到处理机即可运行

	 3,等待状态(又称阻塞状态Blocked):一个进程正在等待某一件事件而暂停
									 运行,如等待资源,等待输入/输出完成
	
	 运行态,可以到就绪态和等待态
	 等待态,可以到就绪态
	 就绪态,可以到运行态

  进程的其他基本状态:
     
     1,创建态(New):一个进程正在被创建,还没被转到就绪态之前的状态

	 2,结束态(Exit):一个进程正在从系统中消失时的状态,这是因为进程结束
				  或由于其他原因所导致。	



进程挂起:

   进程处于挂起状态时,意味着进程没有占用内存空间。处于挂起状态的进程
   映像在磁盘上。

   挂起状态:
     
     1,阻塞挂起状态(Blocked-suspend):进程在外存并等待某事件的出现
	
	 2,就绪挂起状态(Ready-suspend):进程在外存,但只要进入内存,即可运行

   挂起状态转化:

     内存中的状态转换:

     1,阻塞到阻塞挂起:没有进程处于就绪态,或就绪进程要求更多内存资源时,就会
	                  发生这种挂起,以提交新进程或运行就绪进程

	 2,就绪到就绪挂起:当有高优先级阻塞(系统认为很快就绪)进程和低优先级就绪
	                  进程时,系统会选择挂起低优先级就绪进程

	 3,运行到就绪挂起:对抢占式分时系统,当有高优先级阻塞挂起进程因事件出现
	                  而进入就绪挂起时,系统可能会把运行进程转到就绪挂起状态
	 
	 外存中的状态转换:

	 4,阻塞挂起到就绪挂起:当有阻塞挂起进程因相关事件出现时,系统会把阻塞挂起
	                      进程转换为就绪挂起进程


	
	解挂/激活(Activate):把进程从外存转到内存

	  1,就绪挂起到就绪:没有就绪进程或挂起就绪进程优先级高于就绪进程时,会进行
	                   这种转换

	  2,阻塞挂起到阻塞:当一个进程释放足够内存时,系统会把一个高优先级阻塞挂起
	                   (系统认为会很快出现等待事件)进程转换为阻塞进程


    操作系统如何管理这些进程状态:

	  状态队列:

	    1,操作系统维护一组队列,用来表示系统中所有进程的当前状态

		2,不同状态用不同的队列来表示(就绪队列、各种类型的阻塞队列)

	    3,每个进程的PCB根据自己的状态加入到相应的队列当中,当一个进程的
		状态发生变化时,他的PCB从一个状态队列脱离出来,加入到另外一个队列


线程:

  定义:线程是一条执行流程,线程的目的是为了解决并发且多个并发之间共享相同的
       数据

  历史:本来进程功能包含1,数据管理 2,执行 ,后来线程出现后,就把进程的执行功能提取出来
       交给了线程


  线程缺陷:由于线程访问的进程共享资源,如果出现一个线程访问不当，就可能导致整个进程
  崩溃


  线程控制块(TCB):



  线程管理:


线程的实现:

 主要有如下三种实现方式:

  1,用户线程:在用户空间实现


    特点:

     1,操作系统看不到的线程 

	 2,TCB放在用户空间
      
     POSIX Pthreads, Mach C-threads , Solaris threads

	缺点:
	 1,因为系统看不到用户线程,所以进程中的任何一个系统调用,都是以进程的身份
	 发给操作系统的,此时如果进程中的任意一个线程发送了会阻塞的系统调用,操作系统
	 就会阻塞整个进程,即使这个进程的其他线程没有阻塞,也会因为进程被阻塞而全部阻塞

	 2,当一个用户线程开始运行时,由于不被操作系统调度,所以除非他主动交出CPU的
	 使用权,否则它所在的进程中其他线程无法运行(用户线程需要程序员自己调度)
	 
	 3,由于操作系统分时间片是分给进程的,故多线程在单进程中执行时,每个线程
	 得到的时间片较少,执行会比较慢

  2,内核线程:在内核中实现(windows 常用这种进程)

    特点:

     1,操作系统管理起来的线程

	 2,TCB块放在内核中

	 3,没有用户线程的缺点1,内核线程发生系统调用阻塞时仅仅只阻塞自己,他是用自己的
	 身份给操作系统发系统调用的。

     Linux, Windows, Solaris

	缺点:
	  
	  每次内核进程切换时,都会有用户态到内核态的转化,开销较大

  3,轻量级进程:内核中实现,支持用户线程(Linux/Solaris 常用这种线程 )

     特点:
	  
	  1,是内核支持的用户线程

	  2,一个进程可以有多个轻量级进程,每个轻量级进程由一个单独的内核线程
	  支持

     Solaris (LightWeight Process)

 操作系统线程和用户线程的对应关系:

  多对一:多个用户线程对应一个操作系统线程
  一对一:一个用户线程对应一个操作系统线程
  多对多:n个用户线程对应m个操作系统线程

线程和进程的比较:
   
   1,进程是资源分配单位,线程是CPU调度单位

   2,进程拥有一个完整的资源平台,线程只独享他必不可少的资源,如寄存器和栈

   3,线程同样具有就绪、阻塞和执行三种状态,同样具有状态之间的转化关系 (这部分本来是进程功能,后来给了线程)


   4,线程能减少并发执行的时间和空间开销:

     1,线程创建时间比进程时间短
	 2,线程终止时间比进程时间短
	 3,同一进程中的线程切换时间比进程短(因为同一进程的线程页表是相同的,所以切换时不需要切换页表)
	 4,由于同一进程中的多个线程共享资源,可以直接进行不通过内核的通讯

进程的上下文切换:
   
   1,切换时机:
     当CPU需要停止当前运行的进程调度其他进程时，就需要上下文切换，将这些上下文
	 保存在PCB块的某个位置

	 1,必须在切换之前存储多部分的进程上下文:
	    1,寄存器
		2,cpu状态

	 2,进程不能表现出被暂停过，所以必须能够恢复上下文

	 3,上下文转换非常频繁，所以必须快速(所以这部分代码用汇编写)

   

原语:一个完成一定功能的程序段，这段语句要么全部执行，要么一句都不执行

进程创建过程:
  1,申请空白PCB
  2,为新进程分配资源
  3,初始化PCB
  4,将PCB插入就绪队列

进程的终止过程: 
  1,找出被终止进程的PCB
  2,若进程状态为运行态,置CPU调度标志为真(让CPU可以重新调度其他进程)
  3,若有子进程,终止子进程并回收其资源
  4,回收终止进程的资源
  5,回收终止进程的PCB

进程阻塞过程:
  1,调用阻塞原语阻塞自己
  2,将PCB中的状态改变为阻塞,并加入阻塞队列
  3,重新调度其他进程

进程唤醒过程:
  1,阻塞进程等待的事件发生,有关进程调用唤醒原语唤醒等待该事件的进程
  2,置进程状态为就绪态
  3,将进程PCB从阻塞队列转入就绪队列


进程的等待和终止:
  
  1,每个进程执行结束,都会执行exit(msg)来退出这个进程,并向外传出msg

进程相关函数:

  1,fork():一旦执行这个函数,就会将整个进程复制一份新的出来
	vfork():只复制创建进程必备的一部分数据,其他的不复制,因为知道很快会执行exec()
	COW技术(copy on write):这个技术使fork()函数之后发生写操作时才复制进程		
  2,exec('path/command'):在一个进程中加载一个不同的程序并在main开始(实际上是_start),这个函数会将之前fork函数
						 复制的代码段和数据段全都覆盖掉,同时因为执行exec(arg)时,程序arg可能在硬盘上,此时
						 会使进程进入阻塞态等待arg被从硬盘复制到内存中
  3,wait():等待子进程结束,并回收他的PCB,实际上是等待子进程exit(msg)的执行并接收msg
		   主要是因为子进程无法自己回收自己的PCB
			   (当子进程执行exit(),父进程还在执行其他非wait()代码,这是子进程就变成了僵尸进程,一直等着被回收)
			   (若父进程先于他的子进程退出,那么会有一个init进程定期扫描僵尸进程,并代表父进程回收这个僵尸进程)
